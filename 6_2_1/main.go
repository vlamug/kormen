package main

import (
	"fmt"
)

// MaxHeapify поддерживает свойство невозрастающей пирамиды.
// В данном случае значение вершины должно быть меньше значений листьев этой вершины.
// Время работы алгоритма является O(lgn)
func MaxHeapify(arr []int, i int) []int {
	l := left(i)
	r := right(i)

	largest := i
	if l <= len(arr) && arr[l-1] > arr[i-1] {
		largest = l
	}

	if r <= len(arr) && arr[r-1] > arr[largest-1] {
		largest = r
	}

	if largest != i {
		buf := arr[i-1]
		arr[i-1] = arr[largest-1]
		arr[largest-1] = buf

		arr = MaxHeapify(arr, largest)
	}

	return arr
}

// parent возвращает индекс вершины
func parent(i int) int {
	return i/2
}

// left возвращает левый лист
func left(i int) int {
	return 2*i
}

// возвращает правый лист
func right(i int) int {
	return 2*i + 1
}

func main() {
	// В данном случае дерево представленно в виде массива. Дерево должно быть невозрастающим.
	// Корень это первый элемент, то есть 16, он же самый большой по значению.
	// У корня 16 есть два листовых узла - это 4 и 10.
	// У листового узла 4 есть в свою очередь есть также два листовых узла - это 14 и 7 и оба этих значения больше чем 4,
	// что противоречит свойству невозрастающей пиромиды. Следовательно из этих двух нам нужно определить максимальный,
	// и поменять его с 4, чтобы он стал вершиной поддерева. Это делается в функции MaxHeapify.
	// Для листа 10 листовыми узлами являются элементы 9 и 3 и они меньше чем 10, следовательно условие выполняется и
	// делать ничего не нужно.
	// Все остальные элементы также поддерживают свойство невозрастающей пирамиды.
	arr := []int{16, 4, 10, 14, 7, 9, 3, 2, 8, 1}

	fmt.Println(arr)
	arr = MaxHeapify(arr, 2)
	// Результат должны бать следующим: [16 14 10 8 7 9 3 2 4 1] - невозрастающее двоичное дерево в виде массива.
	fmt.Println(arr)
}
